input {
    udp {
        port => 5140
    }
}

filter {

    if [message] =~ /merlin/ {
        ruby {
            code => '
            require "redis"
            r = Redis.new(:host => "cache")
            msg = event.get("message")
            r.rpush("runes",msg)
            #r.publish("qt",ipaddr)
            '
        }
    }

    if "Webconfig: login failure via HTTP" in [message] {
        grok { 
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN006}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocwlclogin"
                }
            }
        }
    } else if "An account failed to log on" in [message] {
        grok { 
            patterns_dir => ["/patterns/"] 
            match => { "message" => "%{PATTERN007}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocwindowslogin"
                }
            }
        }
    } else if "Found Rogue AP!" in [message] {
        grok {
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN003}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocrogueap_found"
                }
            }
        }
    } else if "Lost Rogue AP" in [message] {
        grok { 
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN004}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocrogueap_lost"
                }
            }
        }
    } else if "Interference detected" in [message] {
        grok { 
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN002}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocjamming"
                }
            }
        }
    } else if "sent RADIUS challenge for user id" in [message] {
        grok { 
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN005}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocwlcradiuslogin"
                }
            }
        }
    } else if "WLAN attack detected" in [message] {
        grok { 
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN000}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocwlanattack"
                }
            }
        }
    } else if "m=1209" in [message] {
        grok { 
            patterns_dir => ["/patterns/"]
            match => { "message" => "%{PATTERN001}" }
        }
        if "_grokparsefailure" not in [tags] {
            mutate {
                add_field => {
                    "redischannel" => "siemprocethspoof"
                }
            }
        }
    }
}

output {

    stdout {
        codec => rubydebug
    }

    if [redischannel] {

        redis {
            host => cache
            data_type => "channel"
            key => "%{redischannel}"
        }

        file {
            path => "/log/%{redischannel}-%{+YYYY-MM-dd}.log"
            codec => plain { format => "%{message}" }
        }

    } else {

        file {
            path => "/log/unclassified-%{+YYYY-MM-dd}.log"
            codec => plain { format => "%{message}" }
        }
    }

    #syslog {
    #    port => 514
    #    host => "10.7.1.19"    
    #    protocol => "udp"
    #}

    #syslog {
    #    port => 514
    #    host => "172.25.0.10"
    #    protocol => "udp"
    #}
}
